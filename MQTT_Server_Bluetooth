#include <WiFi.h>                // Bibliothèque WiFi pour se connecter à un réseau sans fil
#include <PubSubClient.h>        // Bibliothèque MQTT pour la communication avec le serveur MQTT
#include <SPI.h>                 // Bibliothèque SPI pour la communication avec le module LoRa
#include <LoRa.h>                // Bibliothèque LoRa pour la communication sans fil à longue portée

#include <stdio.h>               // Bibliothèque standard C pour les entrées/sorties
#include <stdlib.h>              // Bibliothèque standard C pour les fonctions de conversion de type
#include <string.h>              // Bibliothèque standard C pour la manipulation de chaînes de caractères

#define SCK   5                  // Broche SCK pour la communication SPI avec le module LoRa
#define MISO  19                 // Broche MISO pour la communication SPI avec le module LoRa
#define MOSI  27                 // Broche MOSI pour la communication SPI avec le module LoRa
#define SS    18                 // Broche SS pour la communication SPI avec le module LoRa
#define RST   14                 // Broche RST pour la communication SPI avec le module LoRa
#define DI0   26                 // Broche DI0 pour détecter l'interruption LoRa

// Paramètres Bluetooth - L'objectif initial était de les transmettre par LoRa mais par manque de temps nous les avons configurés ici.
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"

// Paramètres pour la configuration WiFi
const char* ssid = "Pixel_5969";
const char* password = "azerty1234";
const char* mqtt_server = "test.mosquitto.org";
int verif = 0;


float d1;                        // Variable pour stocker la première donnée reçue
float d2;                        // Variable pour stocker la deuxième donnée reçue
int y=0;                         // Compteur pour parcourir le tableau de données reçues
long int freq;                   // Variable pour stocker la fréquence utilisée par le module LoRa
long int sf;                     // Variable pour stocker le facteur d'étalement utilisé par le module LoRa
long int sb;                     // Variable pour stocker la largeur de bande utilisée par le module LoRa


WiFiClient espClient;            // Objet pour la connexion WiFi
PubSubClient client(espClient);  // Objet pour la connexion MQTT

// Union pour stocker les données reçues du module LoRa
union pack {
    uint8_t frame[16];
    float data[4]; 
} rdp; 


BLECharacteristic *pCharacteristic; // Déclaration de l'objet pCharacteristic de type BLECharacteristic
bool deviceConnected = false; // Variable booléenne pour savoir si un client est connecté au serveur BLE
bool oldDeviceConnected = false; // Variable booléenne pour savoir si un client était déjà connecté au serveur BLE
unsigned long value; // Stockage du temps écoulé depuis le démarrage de la carte Arduino en millisecondes

void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) { // Boucle d'attente de la connexion Wi-Fi
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void setup() {
  Serial.begin(115200); // Initialisation de la communication série
  setup_wifi(); // Configuration de la connexion Wi-Fi
  client.setServer(mqtt_server, 1883); // Configuration du serveur MQTT
  client.setCallback(callback); // Configuration de la fonction de rappel (callback)

  pinMode(DI0, INPUT); // Configuration de la broche DI0 en entrée
  SPI.begin(SCK,MISO,MOSI,SS); // Initialisation de la communication SPI
  LoRa.setPins(SS,RST,DI0); // Configuration des broches pour le module LoRa

  // Configuration du serveur BLE
  Serial.println("Starting BLE work!");
  BLEDevice::init("IoTDevkit-ESP32"); // Initialisation de l'appareil BLE
  BLEServer *pServer = BLEDevice::createServer(); // Création du serveur BLE
  BLEService *pService = pServer->createService(SERVICE_UUID); // Création du service BLE
  pCharacteristic = pService->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_NOTIFY
  ); // Création de la caractéristique BLE
  pCharacteristic->setValue("Hello World!"); // Définition de la valeur de la caractéristique
  pService->start(); // Démarrage du service

  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising(); // Configuration de la publicité BLE
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(false);
  pAdvertising->setMinPreferred(0x06);  // temps minimal en unités de 0.625 ms
  pAdvertising->setMinPreferred(0x12);  // temps maximal en unités de 0.625 ms
  BLEDevice::startAdvertising(); // Démarrage de la publicité BLE
}

void reconnect() {
  while (!client.connected()) { // Boucle d'attente de la reconnexion au serveur MQTT
    Serial.print("Attempting MQTT connection...");
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    if (client.connect(clientId.c_str())) { // Tentative de connexion au serveur MQTT
      Serial.println("connected");
      client.subscribe("srt/FJ"); // Abonnement au canal "srt/FJ"
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

void callback(char* topic, byte* payload, unsigned int length) {
  char* token;
  char* data_lora[3] = {NULL};
  int token_count = 0;

  char payload_str[length + 1];
  for (int i = 0; i < length; i++) {
    payload_str[i] = (char)payload[i];
  }
  payload_str[length] = '\0';

  //Lecture conntinue des données
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  Serial.println(payload_str);

  // Découpage de la chaîne de caractères en tokens en utilisant l'espace comme délimiteur
  if (verif == 0){
    token = strtok(payload_str, " ");
    while (token != NULL) {
      if (token_count >= 3) {
        // Si nous avons déjà récupéré les trois derniers tokens, sortir de la boucle
        break;
      }
      // Stockage des trois derniers tokens dans last_three_tokens
      Serial.println(token);
      data_lora[token_count] = token;
      token_count++;
      token = strtok(NULL, " ");
    }
  freq = strtol(data_lora[0], NULL, 10);  // Conversion du premier token en long
  //Serial.println(freq); - Test d'affichage des données vérif cohérence - Pas exécuté
  sf = strtol(data_lora[1], NULL, 10); // Conversion du deuxième token en long
  //Serial.println(sf); - Test d'affichage des données vérif cohérence - Pas exécuté
  sb = strtol(data_lora[2], NULL, 10); // Conversion du troisème token en long
  //Serial.println(sb); - Test d'affichage des données vérif cohérence - Pas exécuté
      
  // Initialisation du module LoRa avec la fréquence de communication
  // Si LoRa.begin() renvoie false, cela signifie que l'initialisation a échoué
  if (!LoRa.begin(freq)) {
        Serial.println("Starting LoRa failed!");
  }
  
  // Configuration du facteur d'étalement (spreading factor) et de la bande passante du signal
  LoRa.setSpreadingFactor(sf);
  LoRa.setSignalBandwidth(sb);
  
  // Initialisation de la variable "verif" à 1 pour indiquer que la transmission LoRa est prête
  verif = 1;
void loop() {
  if (!client.connected()) {
    Serial.println("Disconnect");
    reconnect();
  }

  int packetLen; 
  packetLen=LoRa.parsePacket();
  if(packetLen==16){
    y = 0; 
    while (LoRa.available()){
      rdp.frame[y]=LoRa.read(); 
      y++;
  }
 // Lecture des données et force du signal en réception
 d1 = rdp.data[0];
 d2 = rdp.data[1];
 int rssi = LoRa.packetRssi(); //Force du signal en réception en dB
 Serial.println(d1);
 Serial.println(d2);
 Serial.println(rssi);

    // Vérification de la connexion du client
  if (deviceConnected) {
    // Diffusion du message toutes les 5 secondes
    if ((millis() - value) > 5000) {
      value = millis();
      pCharacteristic->setValue("Hello World!");
      pCharacteristic->notify();
      }
    }
    // Vérification du changement d'état de la connexion du client
    if (!deviceConnected && oldDeviceConnected) {
      delay(500); // Déconnexion établie
      BLEDevice::startAdvertising();
      oldDeviceConnected = deviceConnected;
    }
    if (deviceConnected && !oldDeviceConnected) {
      // Connexion établie
      oldDeviceConnected = deviceConnected;
    }
    client.loop();
  }
}
